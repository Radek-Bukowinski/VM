/*
    
    

    1001 1001 1001 1001 -> 9999 in hex

    LOAD INSTRUCTION
    0001 -> load
    0001 -> reg[0]
    0001 -> 1
    0000 -> 0

    MOVE INSTRUCTION
    0010 -> move
    0010 -> reg[1]
    0001 -> reg[0]
    0000 -> 0

    AND INSTRUCTION
    0101 -> and
    0001 -> reg[0]
    0010 -> reg[1]
    0000 -> 0

    dest = reg[0]

    values of reg[0], reg[1] have 'and' operation applied to them
    e.g.

    reg[0] = 0x1111
    reg[1] = 0x1010

    reg[0] = 0x1010 -> holds output value
    reg[1] = 0x1010 -> remains unchanged

MEMORY READ INSTRUCTION

memr r1 &0x11

0x3111

3 = 0011 -> memr decoded
1 = 0001 -> reg[0] = dest
11 = 0001 0001 = src (mem address)


MEMORY WRITE INSTRUCTION

memw &0x12 r1

0x4121

4 = 0100 -> memw decided
12 = 0001 0010 -> dest (mem address)
1 = 0001 -> reg[0] src

PUSH INSTRUCTION
push r1

0xD100

POP INSTRUCTION
pop r1

0xE100

EXAMPLE PROGRAM

load r1 5
memw &0x12 r1
memr r2 &0x12
move r3 r1
syscall exit

0x1150
0x4121
0x3212
0x2310

EXAMPLE PRINT

push 0x48
push 0x65
push 0x6C
push 0x6C
push 0x6F

load 5 arg
syscall stdout
syscall exit


    MEMORY
    ----------------------------------------------
     0 
     |
    ...     USER SPACE
     |
    255 
    ----------------------------------------------
    256
     | 
    ...     PROGRAM SPACE
     |
    384
    ----------------------------------------------
    385
     |
    ...     SYSTEM RESERVED SPACE
     |
    1023
    ----------------------------------------------

    MEMORY_PROGRAM_START =      memory[0x100];
    MEMORY_PROGRAM_END =        memory[0x180];
    MEMORY_FINAL =              memory[0x3FF];
*/